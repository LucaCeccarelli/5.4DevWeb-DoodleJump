<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Jump Amélioré</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
        }
        #score, #level {
            position: absolute;
            top: 10px;
            font-size: 18px;
            color: #333;
        }
        #score { left: 10px; }
        #level { right: 10px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">Score: 0</div>
        <div id="level">Level: 1</div>
        <canvas id="my_canvas" width="320" height="480" style="border: 2px solid black; background-color: white;"></canvas>
    </div>

    <script>
        class Platform {
            static TYPES = {
                NORMAL: 'normal',
                MOVING: 'moving',
                DISAPPEARING: 'disappearing'
            };

            static SPRITE_COORDS = {
                [Platform.TYPES.NORMAL]: [1, 1, 57, 15],
                [Platform.TYPES.MOVING]: [1, 19, 57, 15],
                [Platform.TYPES.DISAPPEARING]: [1, 55, 57, 15]
            };

            constructor(x, y, type = Platform.TYPES.NORMAL) {
                this.x = x;
                this.y = y;
                this.width = 57; // Match spritesheet width
                this.height = 15; // Match spritesheet height
                this.type = type;
                this.movementDirection = Math.random() > 0.5 ? 1 : -1;
                this.touched = false;

                // Properties for falling animation for the platforms of type disappearing
                this.isFalling = false;
                this.fallSpeed = 0;
            }

            update(speed) {
                if (this.type === Platform.TYPES.MOVING && !this.isFalling) {
                    this.x += speed * this.movementDirection;

                    // Reverse direction at screen edges
                    if (this.x <= 0 || this.x + this.width >= 320) {
                        this.movementDirection *= -1;
                    }
                }

                // Handle falling for disappearing platforms
                if (this.isFalling) {
                    this.fallSpeed += 0.5;  // Add to the fall speed a fall acceleration static value of 0.5
                    this.y += this.fallSpeed;
                }
            }

            startFalling() {
                if (this.type === Platform.TYPES.DISAPPEARING) {
                    this.isFalling = true;
                }
            }
        }

        class Model {
            static GRAVITY = 20;
            static JUMP_FORCE = 600;
            static SPEED = 200;
            static PLATFORM_SPEED = 200;
            static CANVAS_WIDTH = 320;
            static CANVAS_HEIGHT = 480;

            constructor() {
                // TODO : The hitbox size is the same size given when 'Drawing' the sprite
                this._hitbox = {
                    width: 50,
                    height: 50
                };
                
                this._direction = 0;
                this._gravitySpeed = 0;
                this._position = { x: Model.CANVAS_WIDTH / 2 - 25, y: Model.CANVAS_HEIGHT / 2 };
                this._score = 0;
                this._level = 1;
                this._platforms = this._generateInitialPlatforms();
                this._generatePlatformsSmartly();
                this._gameOver = false;
                this._highestReachedY = this._position.y;
            }

            get position() { return this._position; }
            get platforms() { return this._platforms; }
            get score() { return this._score; }
            get level() { return this._level; }
            get gameOver() { return this._gameOver; }

            get direction() { return this._direction; }
            set direction(value) { this._direction = value; }

            BindDisplay(callback) {
                this.b_Display = callback;
            }

            _generatePlatformType(level) {
                const random = Math.random();
                
                // Progression de la probabilité des types de plateformes
                if (level <= 3) return Platform.TYPES.NORMAL;
                
                if (level <= 6) {
                    if (random < 0.7) return Platform.TYPES.NORMAL;
                    if (random < 0.9) return Platform.TYPES.MOVING;
                    return Platform.TYPES.DISAPPEARING;
                }
                
                // Niveaux supérieurs : plus de variété
                if (random < 0.5) return Platform.TYPES.NORMAL;
                if (random < 0.8) return Platform.TYPES.MOVING;
                return Platform.TYPES.DISAPPEARING;
            }

            _getTargetPlatformCount() {
                // Desired platforms at level 1 and level 10
                const maxPlatformsAtLevel1 = 10;
                const minPlatformsAtLevel10 = 4;

                // Linear interpolation from 15 down to 5
                // level 1 => 15, level 10 => 5
                const t = (this._level - 1) / (10 - 1);  // Goes from 0.0 (level 1) to 1.0 (level 10)
                const desired = maxPlatformsAtLevel1 - t * (maxPlatformsAtLevel1 - minPlatformsAtLevel10);

                return Math.round(desired);
            }

            _platformConflicts(x, y, width, height, newType) {
                for (let p of this._platforms) {
                    // 1) Check normal bounding-box overlap in X & Y
                    //    (only if we truly want to forbid *any* overlap in both dimensions)
                    const overlapX = (x < p.x + p.width) && (x + width > p.x);
                    const overlapY = (y < p.y + p.height) && (y + height > p.y);

                    if (overlapX && overlapY) {
                        // Already physically overlapping => conflict
                        return true;
                    }

                    // 2) If the new platform is moving, or this existing one is moving,
                    //    forbid *any horizontal overlap* (regardless of Y).
                    if (newType === Platform.TYPES.MOVING || p.type === Platform.TYPES.MOVING) {
                        if (overlapX) {
                            // "Same X level" conflict => we don’t allow it
                            return true;
                        }
                    }
                }
                // If we passed all checks, no conflict
                return false;
            }

            _generateInitialPlatforms() {
                const platformX = Model.CANVAS_WIDTH / 2 - 30;
                const platformY = Model.CANVAS_HEIGHT / 2;

                const platform = new Platform(platformX, platformY, Platform.TYPES.NORMAL);

                // Ensure the player starts on top of that platform so they're safe.
                this._position.x = platformX + (platform.width / 2) - (this._hitbox.width / 2);
                this._position.y = platformY - this._hitbox.height;

                return [platform];
            }

            _generatePlatformsSmartly() {
                // Remove off-screen platforms
                this._platforms = this._platforms.filter(p => p.y < Model.CANVAS_HEIGHT);

                // Define jump constraints
                const MAX_JUMP_HEIGHT = Model.JUMP_FORCE / Model.GRAVITY;
                const MIN_PLATFORM_SPACING = 100;

                // How many total platforms for the current level
                const targetCount = this._getTargetPlatformCount();

                // Generate new platforms until we reach target
                while (this._platforms.length < targetCount) {
                    // Get highest existing platform
                    let highestPlatform = this._platforms.reduce((highest, current) =>
                        current.y < highest.y ? current : highest
                    );

                    // These define the feasible Y range
                    let minY = Math.max(highestPlatform.y - MAX_JUMP_HEIGHT, 15);   // 15 -> platform height
                    let maxY = highestPlatform.y - MIN_PLATFORM_SPACING;

                    // We'll attempt placing one new platform in a loop
                    let tries = 0;
                    let placedPlatform = null;

                    // Pre-generate type only once (so we don't keep randomizing the type in each try)
                    const platformType = this._generatePlatformType(this._level);

                    // 
                    // We push the Y position near the "maxY" for bigger jumps.
                    // fractionOfMaxSpacing goes from 0.5 at level=1 to 1.0 at level=10 (you can tweak!)
                    //
                    const fractionOfMaxSpacing = 0.5 + 0.5 * (Math.min(this._level, 10) / 10);
                    // Example results:
                    //   Level=1 => fraction=0.5+0.5*(1/10) = 0.55 (55% of the gap)
                    //   Level=10 => fraction=0.5+0.5*(10/10) = 1.0 (100% of the gap => near maxY)

                    while (tries < 50 && !placedPlatform) {
                        // Force new platform Y to be near the top end of [minY, maxY].
                        // We'll still add a small random factor, so they’re not all in the exact same spot.
                        const randomJitter = Math.random() * 0.1; // up to +10% wiggle
                        const totalFraction = Math.min(1.0, fractionOfMaxSpacing + randomJitter);

                        const newPlatformY = minY + totalFraction * (maxY - minY);
                        const newPlatformX = this._calculateViableXPosition(newPlatformY);

                        const width = 57;
                        const height = 15;

                        // Check for conflict
                        if (!this._platformConflicts(newPlatformX, newPlatformY, width, height, platformType)) {
                            // If no conflict, create & push
                            placedPlatform = new Platform(newPlatformX, newPlatformY, platformType);
                            this._platforms.push(placedPlatform);
                        }
                        tries ++;
                    }
                    if(tries == 50){
                        console.log("Lol");
                    }
                }
            }

            _calculateViableXPosition(platformY) {
                // Strategy: Look at existing platforms and find a position that could be reachable
                const viablePlatforms = this._platforms.filter(p => 
                    p.y > platformY && p.y <= platformY + Model.JUMP_FORCE / Model.GRAVITY
                );

                if (viablePlatforms.length > 0) {
                    // Choose a platform to base the new platform's X position relative to
                    const referencePlatform = viablePlatforms[Math.floor(Math.random() * viablePlatforms.length)];
                    
                    // Generate X position near the reference platform, with some randomness
                    const baseX = referencePlatform.x;
                    const xVariation = Math.random() * 100 - 50;  // +/- 50 pixels variation
                    
                    return Math.max(0, Math.min(Model.CANVAS_WIDTH - 60, baseX + xVariation));
                }

                // Fallback to completely random if no viable platforms found
                return Math.random() * (Model.CANVAS_WIDTH - 60);
            }

            Move(fps) {
                // Horizontal movement
                this._position.x += this._direction * Model.SPEED / fps;

                // Wrap around screen
                if (this._position.x < -10) this._position.x = Model.CANVAS_WIDTH;
                if (this._position.x > Model.CANVAS_WIDTH) this._position.x = -10;

                // Apply gravity
                this._gravitySpeed += Model.GRAVITY;
                this._position.y += this._gravitySpeed / fps;

                // Update platform movements based on level
                this._platforms.forEach(platform => 
                    platform.update(Model.PLATFORM_SPEED / fps)
                );

                // Check platform collisions
                let isOnPlatform = false;
                for (let platform of this._platforms) {
                    if (
                        this._position.x + this._hitbox.width > platform.x &&
                        this._position.x < platform.x + platform.width &&
                        this._position.y + this._hitbox.height >= platform.y &&
                        this._position.y + this._hitbox.height < platform.y + 10 &&
                        this._gravitySpeed > 0
                    ) {
                        // Different behavior for different platform types
                        switch(platform.type) {
                            case Platform.TYPES.DISAPPEARING:
                                if (!platform.touched) {
                                    this._Jump();
                                    platform.touched = true;
                                    platform.startFalling();
                                }
                                break;
                            default:
                                this._Jump();
                                break;
                        }
                        
                        break;
                    }
                }


                // Scroll platforms and generate new ones
                if (this._position.y < Model.CANVAS_HEIGHT / 2) {
                    const scrollAmount = Model.CANVAS_HEIGHT / 2 - this._position.y;
                    this._position.y += scrollAmount;

                    for (let platform of this._platforms) {
                        platform.y += scrollAmount;
                    }

                    // Increase score and potentially level
                    const scoreIncrease = Math.floor(scrollAmount);
                    this._score += scoreIncrease;
                    this._level = Math.floor(this._score / 1000) + 1;

                    this._generatePlatformsSmartly();
                }

                // Game over if fallen below screen
                if (this._position.y > Model.CANVAS_HEIGHT) {
                    this._gameOver = true;
                }

                this.b_Display(this);
            }

            _Jump() {
                this._gravitySpeed = -Model.JUMP_FORCE;
            }
        }

        class View {
            constructor() {
                this._canvas = document.getElementById('my_canvas');
                this.ctx = this._canvas.getContext('2d');
                this._scoreElement = document.getElementById('score');
                this._levelElement = document.getElementById('level');
                
                // Image loading
                this._backgroundImage = new Image();
                this._backgroundImage.src = './sprites/bck@2x.png';
                
                // Doodle sprites
                this._doodleLeftSprite = new Image();
                this._doodleLeftSprite.src = './sprites/lik-left@2x.png';
                
                this._doodleRightSprite = new Image();
                this._doodleRightSprite.src = './sprites/lik-right@2x.png';
                
                // Platform spritesheet
                this._platformSpritesheet = new Image();
                this._platformSpritesheet.src = './sprites/game-tiles.png';

                // Current sprite direction , different from direction because its for the view
                this._currentDirection = 0;
                this._hold_right = false;
                this._hold_left = false;

                this.Events();
            }

            BindSetDirection(callback) {
                this.b_SetDirection = callback;
            }

            Events() {
                document.addEventListener('keydown', (evt) => {                
                    if (evt.key == 'ArrowLeft' || evt.key == 'ArrowRight') {
                        switch (evt.key) {
                            case 'ArrowLeft':
                                this._hold_left = true;
                                this.b_SetDirection(-1);
                                this._currentDirection = -1;
                                break;
                            case 'ArrowRight':
                                this._hold_right = true;
                                this.b_SetDirection(1);
                                this._currentDirection = 1;
                                break;
                        }
                    }
                });

                document.addEventListener('keyup', (evt) => {
                    switch (evt.key) {
                        case 'ArrowLeft':
                            if (!this._hold_right) {
                                this.b_SetDirection(0);
                            }
                            this._hold_left = false;
                            break;
                        case 'ArrowRight':
                            if (!this._hold_left) {
                                this.b_SetDirection(0);
                            }
                            this._hold_right = false;
                            break;
                    }
                });
            }

            Display(model) {
                let { position, platforms, score, level, gameOver } = model;
                
                this.ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);

                // Draw background image
                if (this._backgroundImage.complete) {
                    // Scale image to fit canvas if needed
                    this.ctx.drawImage(
                        this._backgroundImage, 
                        0, 
                        0, 
                        this._canvas.width, 
                        this._canvas.height
                    );
                }

                // Update score and level
                this._scoreElement.textContent = `Score: ${score}`;
                this._levelElement.textContent = `Level: ${level}`;

                // Draw platforms using sprites
                for (let platform of platforms) {
                    // Only draw if spritesheet is loaded
                    if (this._platformSpritesheet.complete) {
                        // Get sprite coordinates for this platform type
                        const coords = Platform.SPRITE_COORDS[platform.type];
                        
                        this.ctx.drawImage(
                            this._platformSpritesheet,  // Spritesheet image
                            coords[0],  // Source X
                            coords[1],  // Source Y
                            coords[2],  // Source width
                            coords[3],  // Source height
                            platform.x,  // Destination X
                            platform.y,  // Destination Y
                            platform.width,  // Destination width
                            platform.height  // Destination height
                        );
                    } else {
                        // Fallback to colored rectangle if sprite not loaded
                        this.ctx.fillStyle = 'green';
                        this.ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    }
                }

                // Draw player sprite based on direction
                let currentSprite;
                if (this._currentDirection < 0) {
                    currentSprite = this._doodleLeftSprite;
                } else if (this._currentDirection > 0) {
                    currentSprite = this._doodleRightSprite;
                } else {
                    // Use right-facing sprite as default when not moving
                    currentSprite = this._doodleRightSprite;
                }

                // Draw sprite if loaded
                if (currentSprite.complete) {
                    this.ctx.drawImage(
                        currentSprite, 
                        position.x, 
                        position.y, 
                        50,  // Adjust width as needed
                        50   // Adjust height as needed
                    );
                }
                // End Draw Player

                // Game over screen
                if (gameOver) {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
                    
                    //this.ctx.fillStyle = 'white';
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Game Over', this._canvas.width / 2, this._canvas.height / 2);
                    this.ctx.font = '20px Arial';
                    this.ctx.fillText(`Score: ${score}`, this._canvas.width / 2, this._canvas.height / 2 + 40);
                    this.ctx.fillText(`Level: ${level}`, this._canvas.width / 2, this._canvas.height / 2 + 70);
                }
            }
        }

        class Controller {
            constructor(model, view) {
                this._model = model;
                this._view = view;
                
                this._startTime = Date.now();
                this._lag = 0;
                this._fps = 60;
                this._frameDuration = 1000 / this._fps;

                this._model.BindDisplay(this.Display.bind(this));
                this._view.BindSetDirection(this.SetDirection.bind(this));
            }

            Display(model) {
                this._view.Display(model);
            }

            SetDirection(newDirection) {
                this._model.direction = newDirection;
            }
            
            Update() {
                let currentTime = Date.now();
                let deltaTime = currentTime - this._startTime;
                
                this._lag += deltaTime;
                this._startTime = currentTime;

                while (this._lag >= this._frameDuration) {
                    if (!this._model.gameOver) {
                        this._model.Move(this._fps);
                    }
                    this._lag -= this._frameDuration;
                }
                
                requestAnimationFrame(this.Update.bind(this));
            }
        }

        const app = new Controller(new Model(), new View());
        app.Update();
    </script>
</body>
</html>